// contains all Compiler related structure and class definitions
// the only other parts of the compiler are in
// Lex.h Lex.cpp Parse.cpp and LexSymbols.h 
// the first 3 of which are generated by lex and yacc

#pragma once

#include "Tyro.h"
#include "Assembly.h"

#include <hash_map>

// the syntax tree node types
enum NodeType  
{
  // statements
  NT_ERROR,       // error statement

  NT_STMT,        // list of statements [left, right] (left part may be another list)
  NT_PARAM,       // list of expressions (ie parameters) [left, right] (left part may be another list)
  NT_EMPTY,       // empty statement []
  NT_EXPR,        // single expression as statement [expression]
  NT_WHILE,       // while statement [cond, looping part]
  NT_DOWHILE,     // while statement [looping part, cond]
  NT_IFTHEN,      // if statement [cond, if-part]
  NT_IFTHENELSE,  // if statement with else [cond, if-part, else-part]

  // expressions
  NT_BOOLAND,  
  NT_BOOLOR,

  NT_EQUAL,       // equality expression [op1, op2]
  NT_NEQUAL,      // equality expression [op1, op2]
  NT_LESS,        // equality expression [op1, op2]
  NT_LEQUAL,      // equality expression [op1, op2]
  NT_GREATER,     // equality expression [op1, op2]
  NT_GEQUAL,      // equality expression [op1, op2]
  
  NT_ASSIGN,      // assignment expression [variable, op2]

  NT_ADD,         // addition expression [op1, op2]
  NT_SUB,         // subtraction expression [op1, op2]
  NT_MUL,         // multiplication expression [op1, op2]
  NT_DIV,         // division expression [op1, op2]
  NT_MOD,         // mod expression

  NT_CALL,        // function call (link to function table)
  
  NT_IDENT,       // identifier (link to symbol table)

  NT_INT,         // int constant (link to symbol table)
  NT_FLOAT,       // float constant
  NT_BOOL,        // bool constant 

//   NT_COERCE_TO_STR     // coercion to string (from boolean)
};

// data types
enum DataType  
{
  DT_VOID,
  DT_INT,
  DT_FLOAT,
  DT_BOOL
};


// the syntax tree node
// this structure is used for generating a syntax tree 
// based on the input received from the parser
struct Node  
{
  NodeType type;
  DataType rettype;     // the 'return' type of the node
  Node* child[3];       // pointers to children
  
  struct Symbol *symbol;

  dword line;           // the line on which this node begins (used to output syntax error messages)

  Node(NodeType t);
  Node(NodeType t, Node *a);
  Node(NodeType t, Node *a, Node *b);
  Node(NodeType t, Node *a, Node *b, Node *c);

};



// this structure is used for building the intermeidate op sequence (or chain)
// the code is easier to optimize in this state
// this chain is converted to actual bytecode
struct Op
{
  dword offset;   // this is the offset from the beginning of the bytecode buffer
                  // the value is set and is used by Compiler::Build()
  OPCODE opcode;  // see OPCODE in VirtualMachine.h
  dword operand;
  
  // operands
  Symbol *symbol;
  Op *target;

  // the next op in the op chain
  Op *next;

  Op();
  Op(OPCODE opcode);
  Op(OPCODE opcode, dword operand);
  Op(OPCODE opcode, Op *target);
  Op(OPCODE opcode, Symbol *symbol);
  
  ~Op();

  // add op to the end of this chain, returns this
  Op* Concat(Op *op);
};


// this structure is used to describe symbols (non keyword or operator words)
// encountered by the parser, these include but are not limited to:
// type identifiers, contents of constant values and function names
struct Symbol
{
  string contents;    // contents or name as a string

  dword line;         // line on which it was first encountered
  dword index;        // the index of the symbol in the symbol table 
                      // (each symbol type has its own table)

  void *data;         // pointer to additional data
  
  Symbol(const char *contents, dword line);

  dword ToDword();
};


// note: MyComp should be less<string>, but since an implementation of "less" for hash tables
// is missing from MSVC7 we have to use our own class called MyComp
// This should be fixed in subsequent MSVC releases
// typedef hash_map<string, Symbol *, less<string> > SymbolTable;
#include "MyComp.h"
typedef hash_map<string, Symbol *, MyComp> SymbolTable;
typedef hash_map<string, Function *, MyComp> FunctionTable;

#define forEach(type, map, i) for(type::iterator i = map.begin(); i != map.end(); i ++)

// this class is global list of available imports
class ImportList
{
  friend class Compiler;
  FunctionTable functions;

public:

  // adds a single function to the import list
  bool Add(Function *function);

  // adds a number of function at once
  bool AddList(Function functions[], dword count);

  // clears the import list map
  // note: does NOT delete the Function objects
  void Clear();

  // calls Clear()
  ~ImportList();
};


class Compiler
{
  static Compiler *active; // the pointer to the currently active compiler

  Node *tree;
  SymbolTable variables, constants, functions;

  const char *filename;
  dword errorcount;

  // checks whether the imported function is called with the right parameters
  bool CheckFunctionSemantics(Node *node);

  // checks overall semantics of the source code
  bool CheckSemantics(Node *node);

  Op* Build(Node *node);
  bool Assemble(Op *op, Assembly& assembly);

  // moves function pointers from the import list to the assembly
  bool MoveFunctions(Assembly& assembly, ImportList& importlist);

public:

  void Error(const char *message = null, dword line = 0);
  void Error(const char *message, Node *node);

  void SetTree(Node *tree) { this->tree = tree; }

  Symbol* GetVariable(const char *name);
  Symbol* GetConstant(const char *name);

  Symbol* GetFunction(const char *name);

  static inline Compiler* GetActive() { return active; }

  bool Compile(const char *filename, Assembly& assembly, ImportList& importlist);

  Compiler();
  ~Compiler();

};